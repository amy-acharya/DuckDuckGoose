/* autogenerated by Processing revision 1292 on 2023-05-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class DuckDuckGoose extends PApplet {

// declare global variables
Pigeon player;
Duck[] ducks;
Goose[] geese;
int numSprites;

// initialize them in setup().
public void setup(){
  /* size commented out by preprocessor */; // reserved variables width = 800, height = 600
  imageMode(CENTER);

  player = new Pigeon(width / 2.0f, 3.0f);

  // can be changed depending on how many ducks/geese we want
  numSprites = 5;

  ducks = new Duck[numSprites];
  geese = new Goose[numSprites];

  for (int i = 0; i < numSprites; i++) {

    ducks[i] = new Duck(random(width), random(1, 3));
    geese[i] = new Goose(random(width), random(1, 2));
  }
}

// modify and update them in draw().
public void draw(){
  background(255);

  player.display();

  for (int i = 0; i < numSprites; i++) {
    ducks[i].display();
    ducks[i].update();
    System.out.println(player.isTouchingDuck(ducks[i]) + " " + i);
    if (player.isTouchingDuck(ducks[i])) {
      exit();
    }

    geese[i].display();
    geese[i].update();
  } 
} 

// control pigeon using arrow keys
public void keyPressed() {
  if (key == CODED) {
    if (keyCode == LEFT) {
      player.moveLeft();
    }
    else if (keyCode == RIGHT) {
      player.moveRight();
    }
  }
}


/*
TO DO:

- collisions - check for color collision
  - stacking
- track score
  - increment when collision w/ duck
  - reset after collision w/ goose
- splash screen w/ three buttons - start, how to play, history
- level up when touching the top
  - how to make each progressive level harder
- animate sprites
- sprites can go off the screen - fix?

- search method for array
- nested for loop
- recursive formula/function
- execution of how game operates
- creative twist on history of game
*/
public class Duck extends Sprite
{
  private float x;
  private float speed; 
  
  public Duck (float x, float speed)
  {
     super("duck.jpg", 0.3f);
     this.x = x;
     this.speed = speed; 
  }
  
  public void display()
  {
    image(image, x, center_y, w, h);
  }
  
  public void update()
  {
     center_y += speed + change_y;
     if (center_y >= height) {
      center_y = 0;
     }
  }

  // TEST THIS FUNCTION
  public void hide() {
    image(image, 0, 0, 0, 0);
  }

  public float getSpeed() {
    return speed;
  }

  public void setSpeed(int s) {
    speed = s;
  }

  public float getXPos() {
    return x;
  }

  public float getYPos() {
    return center_y;
  }
  
}
public class Goose extends Sprite
{
  private float x;
  private float speed; 
  
  public Goose (float x, float speed)
  {
     super("goose.jpg", 0.3f);
     this.x = x;
     this.speed = speed; 
    
  }
  
  public void display()
  {
    image(image, x, center_y, w, h);
    if (center_y >= height) {
      center_y = 0;
    }
  }
  
   public void update()
   {
     center_y += speed + change_y;
   }
  
}
public class Level {
    private int num;
    private float fallSpeed;
    private int nSprites;
    private int scoreNeeded;

    public Level (int num, float fallSpeed, int nSprites, int scoreNeeded) {
        this.num = num;
        this.fallSpeed = fallSpeed;
        this.nSprites = nSprites;
        this.scoreNeeded = scoreNeeded;
    }

    public void display() {
        text("Level " + num, 0, 0);
    }
}
public class Pigeon extends Sprite {
    private float x;
    private float speed;
    private boolean alive;
    int score;

    public Pigeon (float x, float speed)
    {
        super("pigeon.png", 0.2f);
        this.x = x;
        this.speed = speed; 
        this.alive = true;
        this.score = 0;
    }
  
    public void display()
    {
        image(image, x, height - 100, w, h);
    }
  
    public void moveLeft()
    {
        x -= speed + change_x;

        // collision with wall
        if (x >= width) {
            x = width - super.getWidth();
        }
    }

    public void moveRight()
    {
        x += speed + change_x;

        // collision with wall
        if (x <= 0) {
            x = 0;
        }
    }

    public void incrementScore() {
        score++;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int s) {
        score = s;
    }

    public boolean isTouchingDuck(Duck d) {
        float xPos = (x + super.getWidth() / 2);
        float yPos = height - 100; //- super.getHeight();
        float duckXPos = d.getXPos();
        float duckYPos = d.getYPos() + d.getHeight() / 2;
        float xBuffer = super.getWidth() / 2 + d.getWidth() / 2;

        // System.out.println("xPos " + xPos);
        // System.out.println("duck x " + duckXPos);
        // System.out.println("xbuffer " + xBuffer);

        System.out.println("yPos " + yPos);
        System.out.println("duck y " + duckYPos);

        if (Math.abs(xPos - duckXPos) < xBuffer) {
            System.out.println("in outer if");
            if (Math.abs(yPos - duckYPos) < 10) {
                System.out.println("in inner if");
                return true;
            }
        }
        return false;

        // loadPixels(d);
        // color c = pixels[yPos * width + xPos];
        // color c = get(xPos, yPos);
    }
}
public class Sprite {
  PImage image;
  float center_x, center_y;
  float change_x, change_y;
  float w, h; 
  
  public Sprite(String filename, float scale, float x, float y){
    // inititalize variables in this constructor.
    // initialize image by calling loadImage(filename)
    image = loadImage(filename);
    center_x = x;
    center_y = y;
    change_x = 1;
    change_y = 1;
    w = image.width * scale;
    h = image.height *scale;
  }
  // write constructor with filename and scale parameters only.
  public Sprite(String filename, float scale){

    image = loadImage(filename);
    center_x = 10;
    center_y = 10;
    change_x = 1;
    change_y = 1;
    w = image.width * scale;
    h = image.height *scale;
  
  }
  
  public void display(){
    // use image(image_file, x, y, width_image, height_image) to draw image.
    image(image, center_x, center_y, w, h);
    
  }
  public void update(){
    // update position by adding velocity in each direction

      center_y += 2 + change_y;
      
  }

  public float getWidth() {
    return w;
  }

  public float getHeight() {
    return h;
  }

  public float getXPos() {
    return center_x;
  }
  
  public float getYPos() {
    return center_y;
  }
}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "DuckDuckGoose" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
